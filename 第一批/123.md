# 使用canvas画出一个矩形

# 什么是zoom？它有什么作用？

zoom可以缩放元素，类似transform:scale()

zoom是IE浏览器的专有属性，它的缩放基点在元素左上角，会影响到元素布局

transform:scale()的缩放基点在元素中心，不影响布局

# 分析`('b' + 'a' + +'a' + 'a').toLowerCase()`返回的结果

+'a'这里的+是在转化类型，得到的结果是number类型的NaN

所以连起来baNaNa，最后转为小写banana

# 你了解雅虎前端优化的35条军规吗？你能说上几条？

- 减少http请求数，合并js、css、图片、行内图片
- 减少dns查询，dns查询要花费20~120毫秒，在地址栏输入url后查询出dns结果前，浏览器什么也不会加载；原则上要把组件分散在2~4个主机名下，这是同时减少dns查询和允许高并发下载的折中方案
- 避免重定向，多重定向时用户看不到任何内容。如果必须重定向，推荐使用3xx状态码，这样可以让浏览器的回退按钮能正常使用
- 缓存ajax请求，如果ajax请求中有Expires或Cache-Control，那么在过期前应该使用缓存内容，避免在来一次http请求；可以在url中添加一个表明资源最后修改时间的时间戳
- 延迟加载，包括：非首屏使用的数据、样式、脚本、图片；用户交互时才会显示的内容
- 预加载，利用浏览器空闲时间请求将来要使用的资源
- 减少dom元素数据，复杂的页面字节数更大、js的dom操作也更慢
- 划分内容到不同域名，浏览器会限制从同一个域下可以同时请求的数量，但域名保持在2~4个
- 尽量减少iframe的使用，iframe优点：用作安全沙箱、并行下载脚本；缺点，加载代价高昂、阻塞页面load事件
- 避免404错误，http请求很昂贵，返回无效的响应没必要，降低用户体验
- 使用cdn，加快资源下载
- 添加Expires或Cache-Control，静态内容设置为将来很远的时间实现永不过期，动态内容设置合适的Cache-Control，让浏览器有条件的发起请求
- 启用gzip
- 配置etag实体标签，在响应头中etag值，浏览器发起请求时设置请求头if-none-match带上etag的值，来向服务器验证资源是否过期
- 尽早输出flush缓冲，如果用php的话
- ajax请求使用get方法，因为发post请求的话，浏览器会先发送请求头，再发送data，而get请求只需发送一次
- 避免img的src为空，如果src为空时，IE会向所在的目录发送请求、Chrome会向页面本身发起请求，这回浪费浏览器资源和宽带
- 减少cookie大小，降低cookie大小对响应速度的影响
- 静态资源使用无cookie域名，通常静态资源不需要cookie，降低cookie传输造成的流量浪费
- 把样式放在head中，解析页面时，浏览器在发现css就会马上异步发起请求，可以让内容尽早反馈在页面上
- 不使用css表达式，css表达式可以执行js代码，仅ie5~7支持，已被废弃
- 使用<link>替代@import，@import会在css加载和解析之后才开始下载，link会在浏览器发现时就立马开始
- 不使用AlphaImageLoader，IE5~8专有，已被废弃
- 把脚本放在body底部或添加defer、async属性
- 使用外部js和css，外部js和css可以被浏览器缓存，也能降低页面大小
- 压缩js和css，加快下载
- 移除重复脚本，避免不必要的http请求
- 减少dom操作，因为dom操作很慢
- 使用高效的事件处理，减少事件监听的节点，如通过事件委托；尽早处理，在DOMContentLoaded就可处理的，不要等到load以后
- 优化图片，减少图片大小
- 优化css sprite，水平排列图片、把颜色较近的图片组合在一起理想状况时低于256色使用png8格式、不要sprite图片中存在较大空隙（虽然不会增加文件大小，但可能会增加移动端对图片的解析时间）
- 不要再html中缩放图片，img的width和height应该跟图片的实际大小保持一致
- 使用体积小、可缓存的favion.ico，无论是否设置再页面中，浏览器都会去请求，确保避免404、最好小于1k、设置较长的过期时间
- 保证所有组件都小于25k，因为iphone不缓存大于25k的组件
- 打包内容为分段文档，可以用一个http请求获取到多个组件

# [NodeJs] NodeJs的回调有什么用吗？

由于nodejs的io操作是异步的，用户为了拿到异步操作的结果，就采取回调函数的方式去拿操作的结果，因为错误优先原则需要先判断是否有错误

# vue在组件中引入插件的方法有哪些？

- 全局引入，Vue.use(plugin)
- 局部引入，export default{ plugins:[ myPlugin({}) ] }